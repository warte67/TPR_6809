                      ; ****************
                      ; * ROM_E000.asm *
                      ; ****************
                              
                      
                      ; system call macro to support the Warte variant 
                      ;               of the MC6809e, the 6809w. This replaces
                      ;               the SWI3 instruction with the SYS #n OS9 
                      ;               style system call instruction.
                      SYS             macro
                                      SWI3
                                      fcb             \1              
                                      endm
                                              
                      
                                              
                      
                      ; **************
                      ; * MEMORY MAP *
                      ; **************
0000                                                  org     $0000
                                                      
0000  E020            SOFT_RESET      fdb     do_RESET        ; Software RESET Vector
0002  E00B            SOFT_NMI        fdb     do_NMI          ; Software NMI Vector
0004  E00E            SOFT_SWI        fdb     do_SWI          ; Software SWI Vector
0006  E011            SOFT_IRQ        fdb     do_IRQ          ; Software IRQ Vector
0008  E014            SOFT_FIRQ       fdb     do_FIRQ         ; Software FIRQ Vector
000A  E017            SOFT_SWI2       fdb     do_SWI2         ; Software SWI2 Vector
000C  E01A            SOFT_SWI3       fdb     do_SWI3         ; Software SWI3 Vector
000E  E01D            SOFT_RSRVD      fdb     do_RSRV         ; Software Motorola Reserved Vector
                      
                      ; reserved system variables
0010  E079            EXEC_VECTOR             fdb             reset                   ; execution vector 
                      
0012  00              TCSR_ROW                fcb             0                               ; current text cursor row
0013  00              TCSR_COL                fcb             0                               ; current text cursor column
0014  10              TCSR_ATTRIB             fcb             $10                             ; current cursor attribute
0015  A2              TEXT_ATTRIB             fcb             $a2                             ; current text attribute
0016  0000            TCSR_DECAY              fdb             $0000                   ; counter delay for the cursor
0018  00              TCSR_ANC_ROW    fcb             0                               ; beginning row of line currently being edited
0019  00              TCSR_ANC_COL    fcb             0                               ; beginning column of line currently being edited
001A  0000            TCSR_ANC_ADR    fdb             0                               ; anchor address
001C  0000            TCSR_EDT_ADR    fdb             0                               ; address when enter was pressed during line edit
                      
001E                                          INCLUDE "mem_map.asm"
                      ;  **********************************************
                      ;  * Allocated 64k Memory Mapped System Symbols *
                      ;  **********************************************
                      
                      
                      ;  Zero-Page Kernal Variables:
0010                  SYSTEM_VARS     equ     $0010   ; start kernal vectors and variables
                      
                      ;  Stack Frames:
0100                  U_STK_BTM       equ     $0100   ; 256 bytes default user stack space
0200                  U_STK_TOP       equ     $0200   ; User Stack initial address
0200                  S_STK_BTM       equ     $0200   ; 512 bytes default system stack space
0400                  S_STK_TOP       equ     $0400   ; System Stack initial address
                      
                      ;  Video Buffer Memory (target = $0400):
0400                  VIDEO_START     equ     $0400   ; Start of 5KB Video Buffer Memory
17FF                  VIDEO_END       equ     $17ff   ; Last Byte of 5KB Video Buffer Memory
                      
                      ;  Graphics Hardware Registers:
1800                  GFX_BEGIN       equ     $1800   ; start of graphics hardware registers
1800                  GFX_FLAGS       equ     $1800   ; (Byte) gfx system flags:
                                                      ;      bit 7: VSYNC
                                                      ;      bit 6: backbuffer enable
                                                      ;      bit 5: swap backbuffers (on write)
                                                      ;      bit 4: reserved
                                                      ;      bits 2-3 = 'Background' graphics modes (20KB buffer)
                                                      ;          0) NONE (forced black background)
                                                      ;          1) Tiled 16x16 mode
                                                      ;          2) Overscan Tile 16x16 mode
                                                      ;          3) 128x80 x 256-Colors
                                                      ;      bits 0-1 = 'Foreground' graphics modes (5KB buffer)
                                                      ;          0) 256x160 x 2-Color (with disable flag)
                                                      ;          1) Glyph Mode (32x20 text)
                                                      ;          2) Glyph Mode (64x40 text)
                                                      ;          3) 128x80 x 16-Color
1801                  GFX_AUX equ     $1801   ; (Byte) gfx auxillary/emulation flags:
                                                      ;      bit 7: 1:fullscreen / 0:windowed
                                                      ;      bit 6: reserved
                                                      ;      bit 5: reserved
                                                      ;      bit 4: reserved
                                                      ;      bit 3: reserved
                                                      ;      bit 0-2: monitor display index (0-7)
1802                  GFX_TIMING_W    equ     $1802   ; (Word) horizontal timing
1804                  GFX_TIMING_H    equ     $1804   ; (Word) vertical timing
1806                  GFX_PAL_INDX    equ     $1806   ; (Byte) gfx palette index (0-15)
1807                  GFX_PAL_DATA    equ     $1807   ; (Word) gfx palette color bits RGBA4444
                      
                      ;  Paged Foreground Graphics Mode Hardware Registers:
1809                  GFX_FG_BEGIN    equ     $1809   ; start of paged foreground gfxmode registers
1809                  GFX_FG_WDTH     equ     $1809   ; (Byte) Foreground Unit Width-1
180A                  GFX_FG_HGHT     equ     $180a   ; (Byte) Foreground Unit Height-1
180A                  GFX_FG_END      equ     $180a   ; end of paged foreground gfxmode registers
                      
                      ;  Paged Background Graphics Mode Hardware Registers:
180B                  GFX_BG_BEGIN    equ     $180b   ; start of paged background gfxmode registers
180B                  GFX_EXT_ADDR    equ     $180b   ; (Word) 20K extended graphics addresses
180D                  GFX_EXT_DATA    equ     $180d   ; (Byte) 20K extended graphics RAM data
180D                  GFX_BG_END      equ     $180d   ; end of paged background gfxmode registers
                      
                      ;  Mouse Cursor Hardware Registers:
180E                  CSR_BEGIN       equ     $180e   ; start of mouse cursor hardware registers
180E                  CSR_XPOS        equ     $180e   ; (Word) horizontal mouse cursor coordinate
1810                  CSR_YPOS        equ     $1810   ; (Word) vertical mouse cursor coordinate
1812                  CSR_XOFS        equ     $1812   ; (Byte) horizontal mouse cursor offset
1813                  CSR_YOFS        equ     $1813   ; (Byte) vertical mouse cursor offset
1814                  CSR_SIZE        equ     $1814   ; (Byte) cursor size (0-15) 0:off
1815                  CSR_SCROLL      equ     $1815   ; (Signed) MouseWheel Scroll: -1, 0, 1
1816                  CSR_FLAGS       equ     $1816   ; (Byte) mouse button flags:
                                                      ;      bits 0-5: button states
                                                      ;      bits 6-7: number of clicks
1817                  CSR_PAL_INDX    equ     $1817   ; (Byte) mouse cursor color palette index (0-15)
1818                  CSR_PAL_DATA    equ     $1818   ; (Word) mouse cursor color palette data RGBA4444
181A                  CSR_BMP_INDX    equ     $181a   ; (Byte) mouse cursor bitmap pixel offset
181B                  CSR_BMP_DATA    equ     $181b   ; (Byte) mouse cursor bitmap pixel index color
181B                  CSR_END equ     $181b   ; end of mouse cursor hardware registers
                      
                      ;  Debugger Hardware Registers:
181C                  DBG_BEGIN       equ     $181c   ; Start of Debugger Hardware Registers
181C                  DBG_BRK_ADDR    equ     $181c   ; (Word) Address of current breakpoint
181E                  DBG_FLAGS       equ     $181e   ; (Byte) Debug Specific Hardware Flags
                                                      ;      bit 7: Debug Enable
                                                      ;      bit 6: Single Step Enable
                                                      ;      bit 5: clear all breakpoints
                                                      ;      bit 4: Toggle Breakpoint at DEBUG_BRK_ADDRESS
                                                      ;      bit 3: FIRQ  (on low to high edge)
                                                      ;      bit 2: IRQ   (on low to high edge)
                                                      ;      bit 1: NMI   (on low to high edge)
                                                      ;      bit 0: RESET (on low to high edge)
181E                  DBG_END equ     $181e   ; End of the Debugger Hardware Registers
                      
                      
181F                  GFX_END equ     $181f   ; end of the GFX Hardware Registers
                      
                      ;  File I/O Hardware Registers:
181F                  FIO_BEGIN       equ     $181f   ; start of file i/o hardware registers
181F                  FIO_ERR_FLAGS   equ     $181f   ; (Byte) file i/o system flags:
                                                      ;      bit 7:   file not found
                                                      ;      bit 6:  end of file
                                                      ;      bit 5:   buffer overrun
                                                      ;      bit 0-4: not yet assigned
1820                  FIO_COMMAND     equ     $1820   ; (Byte) OnWrite - command to execute
                                                      ;      $00 = Reset/Null
                                                      ;      $01 = Open/Create Binary File for Reading
                                                      ;      $02 = Open/Create Binary File for Writing
                                                      ;      $03 = Open/Create Binary File for Append
                                                      ;      $04 = Close File
                                                      ;      $05 = Read Byte
                                                      ;      $06 = Write Byte
                                                      ;      $07 = Load Hex Format File
                                                      ;      $08 = Write Hex Format Line
                                                      ;      $09 = Get File Length (FIO_BFRLEN = file length
                                                      ;      $0A = Load Binary File (read into FIO_BFROFS - FIO_BFROFS+FIO_BFRLEN)
                                                      ;      $0B = Save Binary File (wrote from FIO_BFROFS to FIO_BFROFS+FIO_BFRLEN)
                                                      ;      $0C = (not yet designed) List Directory
                                                      ;      $0D = Make Directory
                                                      ;      $0E = Change Directory
                                                      ;      $0F = Rename Directory
                                                      ;      $10 = Remove Directory
                                                      ;      $11 = Delete File
                                                      ;      $12 = Rename file
                                                      ;      $13 = Copy File
                                                      ;      $14 = Seek Start
                                                      ;      $15 = Seek Current
                                                      ;      $16 = Seek End
                                                      ;      $17 = SYSTEM: Shutdown
1821                  FIO_HANDLE      equ     $1821   ; (Byte) file handle or ZERO
1822                  FIO_BFROFS      equ     $1822   ; (Word) start of I/O buffer
1823                  FIO_BFRLEN      equ     $1823   ; (Word) length of I/O buffer
1825                  FIO_SEEKOFS     equ     $1825   ; (Word) seek offset
1827                  FIO_FILEPATH    equ     $1827   ; (Char Array 256) file path and argument buffer
1927                  FIO_END equ     $1927   ; end of file i/o hardware registers
                      
                      ;  Keyboard Hardware Registers:
1928                  KEY_BEGIN       equ     $1928   ; start of keyboard hardware registers
1928                  CHAR_Q_LEN      equ     $1928   ; (char) # of characters waiting in queue       (Read Only)
1929                  CHAR_SCAN       equ     $1929   ; read next character in queue       (not popped when read)
192A                  CHAR_POP        equ     $192a   ; (char) next character waiting in queue (popped when read)
192B                  XKEY_BUFFER     equ     $192b   ; (128 bits) 16 bytes for XK_KEY data buffer    (Read Only)
193B                  EDT_BFR_CSR     equ     $193b   ; (Byte) cursor position within edit buffer    (Read/Write)
193C                  EDT_BUFFER      equ     $193c   ; (256 Bytes) line editing character buffer    (Read/Write)
1A3C                  KEY_END equ     $1a3c   ; end of keyboard hardware registers
                      
                      ;  Reserved Hardware:
1A3D                  RESERVED_HDW    equ     $1a3d   ; Reserved 1470 bytes ($1A3D - $1FFB)
                      
                      ;  Memory Bank Selects (16MB):
1FFC                  RAMBANK_SEL_1   equ     $1ffc   ; (Word)Indexes 65536 x 8kb banks
1FFE                  RAMBANK_SEL_2   equ     $1ffe   ; (Word)Indexes 65536 x 8kb banks
                      
                      ;  Standard Usable (from FAST static 32KB) RAM:
2000                  RAM_START       equ     $2000   ; Begin System RAM (32k)
9FFF                  RAM_END equ     $9fff   ; End System RAM
                      
                      ;  Switchable RAM Banks (from SLOW external serial 16MB RAM chip):
A000                  RAM_BANK_1      equ     $a000   ; switched 8KB ram bank 1
C000                  RAM_BANK_2      equ     $c000   ; switched 8KB ram bank 2
                      
                      ;  Bios Kernal ROM:
E000                  BIOS_ROM        equ     $e000   ; Begin BIOS Kernal ROM (8KB)
                      
                      
                      
                      ; ***************************************
                      ; * Read Only Sytem KERNAL ROM          *
                      ; ***************************************
                                            
                       
001E                  SECTION.CODE
E000                                          org     $E000  
                                  ;* Power On Initialization            
E000                  ROM_ENTRY   
E000  CE0200                                  LDU             #U_STK_TOP              ; top of user stack     
E003  10CE0400                                LDS     #S_STK_TOP              ; top of stack space            
E007  6E9F0000                    JMP     [SOFT_RESET]      
                      
                                  
                                  ;* NMI Vector Handler                     
E00B  7EE023          do_NMI      JMP just_rti
                                  
                                  ;* SWI Vector Handler (do_SWI)   
E00E  7EE023          do_SWI          JMP just_rti
                      
                                  ;* IRQ Vector Handler         
E011  7EE023          do_IRQ      JMP just_rti
                      
                                  ;* FIRQ Vector Handler         
E014  7EE023          do_FIRQ     JMP just_rti
                      
                                  ;* SWI2 Vector Handler         
E017  7EE023          do_SWI2     JMP just_rti
                      
                                  ;* SWI3 Vector Handler         
E01A  7EE023          do_SWI3     JMP just_rti
                      
                                  ;* Reserved Vector Handler
E01D  7EE079          do_RSRV     JMP reset
                      
                                  ;* Reset Vector Handler         
E020  7EE079          do_RESET    JMP reset
                                  
                      ;********************
                      ;* RESET
                      ;**************************                     
                                              
                      ; NOTES:  
                      ;
                      ;                       SYNC still needs to be implemented along with NMI, IRQ, and FIRQ handlers
                      
E023                  just_rti        
E023  3B                                      rti 
                      
E024  2E2F61736D2F746573742E68657800 test_file       fcn             "./asm/test.hex"
                      
E033  54776F2D504920526574726F20363830390A prompt_msg      fcc             "Two-PI Retro 6809\n"
E045  42494F53204B45524E454C20762E302E30320A                         fcc             "BIOS KERNEL v.0.02\n"
E058  436F707972696768742032303233206279204A6179204661726965730A0A                         fcc             "Copyright 2023 by Jay Faries\n\n"
E076  4F4B00          prompt_ready fcn        "OK"
                      
E079                  reset           
                                              ; display the starting screen
E079  BDE218                                  jsr             starting_screen
E07C  860A                                    lda             #$0a
E07E  BDE173                                  jsr             char_out
                                              ; fresh anchor
E081  B60012                                  lda             TCSR_ROW
E084  B70018                                  sta             TCSR_ANC_ROW
E087  B60013                                  lda             TCSR_COL
E08A  B70019                                  sta             TCSR_ANC_COL
E08D  7F001A                                  clr             TCSR_ANC_ADR
E090  7F001B                                  clr             TCSR_ANC_ADR+1                  
                      
                                      ; main KERNEL loop
E093  C610                                    ldb             #$10
E095  F70014                                  stb             TCSR_ATTRIB
E098  CC0000                                  ldd             #0
E09B  FD0016                                  std             TCSR_DECAY
                      
E09E                  main_kernel
                                              ; rotate the cursor attributes
E09E  FC0016                                  ldd             TCSR_DECAY              ; load the cursor delay
E0A1  C30001                                  addd    #1                              ; increment it
E0A4  FD0016                                  std             TCSR_DECAY              ; store it      
E0A7  10830200                                cmpd    #$200                   ; check if delay has expired
E0AB  2D15                                    blt             1f                              ; skip past the color update
E0AD  7C0014                                  inc             TCSR_ATTRIB             ; increment the color attribute
E0B0  CC0000                                  ldd             #0                              ; reset the cursor delay
E0B3  FD0016                                  std             TCSR_DECAY              ; store the reset delay
                      
                                              ; mark the anchor
E0B6  B60018                                  lda     TCSR_ANC_ROW    ; A: text cursor row
E0B9  F60019                                  ldb             TCSR_ANC_COL    ; B: text cursor column
E0BC  BDE1F9                                  jsr             tcsr_pos_reg    ; X: calculated offset within the video buffer
E0BF  BF001A                                  stx             TCSR_ANC_ADR
                      
                      ;; color the anchor character
                      ;                       ldb             #$3B                    ; anchor color attribute
                      ;                       stb             1,X                             ; highlight the anchor character
                      
E0C2                  1                       ; display the cursor
                      
E0C2  BDE1EB                                  jsr             tcsr_pos                ; fetch x from row/col
E0C5  8620                                    lda             #' '                    ; space character
E0C7  F60014                                  ldb             TCSR_ATTRIB             ; load the current attribute
E0CA  ED84                                    std             0,x                             ; place the cursor onto the screen
                                              
                                              ; check for a key in the queue
E0CC  B61928                                  lda             CHAR_Q_LEN              ; load the length of the key queue
E0CF  27CD                                    beq             main_kernel             ; loop if nothing is queued
                      
                                              ; delete the old cursor
E0D1  BDE1EB                                  jsr             tcsr_pos                ; calculate X from row/col
E0D4  8620                                    lda             #' '                    ; load a blank space character
E0D6  F60015                                  ldb             TEXT_ATTRIB             ; load the current text attribute
E0D9  ED84                                    std             0,x                             ; store the colored character at X (row/col)
                                              
                                              ; display typed character
E0DB  B6192A                                  lda             CHAR_POP                ; pop the last typed character  
                      
                                              ; was [ENTER] pressed
E0DE  810D                                    cmpa    #$0D                    ; check for [ENTER]
E0E0  262F                                    bne     2f                              ; nope, that wasn't it. Skip ahead to 2
                      
E0E2  3402                                    pshs    A                               ; save the typed key
E0E4  B60012                                  lda             TCSR_ROW                ; A: current cursor row
E0E7  F60013                                  ldb             TCSR_COL                ; B: current cursor column
E0EA  BDE1F9                                  jsr             tcsr_pos_reg    ; X: calculated offset 
E0ED  BF001C                                  stx             TCSR_EDT_ADR    ; save as the end of the current edit buffer
                      
                      ;;                      ; color highlight the pending string 
                      ;                       ldb             #$4c            
                      ;                       ldx             TCSR_ANC_ADR                    
                      ;                       leax    1,x
                      ;99                     stb             ,x++
                      ;                       cmpx    TCSR_EDT_ADR
                      ;                       blt             99b
                      
                                              ; copy the string to the hardware buffer
E0F0  108E193C                                ldy             #EDT_BUFFER             ; Y: current hardware edit buffer
E0F4  BE001A                                  ldx             TCSR_ANC_ADR    ; X: anchor or start of the edit string
E0F7  A681            4                       lda             ,x++                    ; load the character from the screen
E0F9  A7A0                                    sta             ,y+                             ; store it into the hardware edit buffer
E0FB  BC001C                                  cmpx    TCSR_EDT_ADR    ; check for the end of the string
E0FE  2DF7                                    blt             4b                              ; keep looping if not at the end
E100  6FA4                                    clr             ,y                              ; append a NULL character in the hardware buffer
                                              ;lda            #$0a
                                              ;jsr    char_out
E102  BDE264                                  jsr             execute_command ; parse and run the command                     
E105  3502                                    puls    A                               ; A: restored Key typed
                                              
E107  BE0012                                  ldx             TCSR_ROW
E10A  BC0018                                  cmpx    TCSR_ANC_ROW
E10D  2702                                    beq             2f
E10F  2003                                    bra             3f
E111                  2
E111  BDE173                                  jsr             char_out                ; display the last typed character
E114                  3
E114  810D                                    cmpa    #$0D                    ; Was [ENTER] pressed?
E116  261A                                    bne             2f                              ; no, move on
                      
                                              ; [ENTER] pressed                       
E118  B60018                                  lda             TCSR_ANC_ROW
E11B  F60019                                  ldb             TCSR_ANC_COL
E11E  BDE1F9                                  jsr             tcsr_pos_reg
E121  F60015                                  ldb             TEXT_ATTRIB
E124  E701                                    stb             1,x
                      
                                              ; move the anchor to the new cursor position
E126  B60012                                  lda             TCSR_ROW
E129  B70018                                  sta             TCSR_ANC_ROW
E12C  B60013                                  lda             TCSR_COL
E12F  B70019                                  sta             TCSR_ANC_COL
E132                  2
                                              ; display the new cursor
E132  BDE1EB                                  jsr             tcsr_pos                ; fetch x from row/col
E135  8620                                    lda             #' '                    ; space character
E137  F60014                                  ldb             TCSR_ATTRIB             ; load the current attribute
E13A  ED84                                    std             0,x                             ; place the cursor onto the screen              
                      
                                              ; end of main kernel loop
E13C  7EE09E                                  jmp             main_kernel             ; continue the main kernel loop
                      
                      
                      ; **** SUBROUTINES ***************************************************
                      
                      
                      ; FILE SYSTEM TESTS:
                      
E13F                  test_load_hex
                                              ; load "test.hex"
E13F  8EE024                                  ldx             #test_file              ; fetch the filename
E142  108E1827                                ldy             #FIO_FILEPATH   ; fetch the filename hardware register storage
E146                  1
E146  A680                                    lda             ,x+                             ; copy a character from the source filename
E148  A7A0                                    sta             ,y+                             ; store it in the hardware register
E14A  26FA                                    bne             1b                              ; keep looping until null-termination
                      
E14C  8607                                    lda             #$07                    ; command: LoadHex
E14E  B71820                                  sta             FIO_COMMAND             ; executre the command
E151  B6181F                                  lda             FIO_ERR_FLAGS   ; load the errors flag
E154  8180                                    cmpa    #$80                    ; test for bit: file not found?
E156  2700                                    beq             1f                              ; dont call the sub if it wasnt loaded
                      
                      
                                              ;jsr            [$0010]                 ; call the loaded subroutine
                      
                      
E158                  1
E158  39                                      rts
                      
                      
                      ; **** SYSTEM CALLS ******************************
                      
E159                  clear_text_screen       ; clear the text screen
E159  3416                                    pshs    D,X
E15B  8E0400                                  ldx             #VIDEO_START
E15E  8620                                    lda             #' '
E160  F60015                                  ldb             TEXT_ATTRIB
E163  ED81            1                       std             ,x++
E165  8C17FF                                  cmpx    #VIDEO_END
E168  23F9                                    bls             1b      
E16A  3516                                    puls    D,X             
E16C  7F0012                                  clr             TCSR_ROW
E16F  7F0013                                  clr             TCSR_COL                        
E172  39                                      rts
                      
                      
E173                  char_out        ; Display character in the A register to the screen
                                              ; at the current cursor position and in the 
                                              ; current color.
E173  3436                                    pshs    D, X, Y
                      
                                              ; just return if A=null
E175  4D                                      tsta
E176  2762                                    beq             3f
E178  F60015                                  ldb             TEXT_ATTRIB
E17B  8D6E                                    bsr             tcsr_pos                ; find X from Row and Col
E17D  810A                                    cmpa    #$0a
E17F  2719                                    beq             _cr
E181  810D                                    cmpa    #$0D
E183  2715                                    beq             _cr
E185  8108                                    cmpa    #$08                    ; backspace
E187  2721                                    beq             _backspace
E189  8120                                    cmpa    #$20
E18B  2D4D                                    blt             3f
                                              ; standard printable character
E18D  ED84                                    std             ,x
E18F  7C0013                                  inc             TCSR_COL
E192  B60013                                  lda             TCSR_COL
E195  B11809                                  cmpa    GFX_FG_WDTH
E198  2340                                    bls             3f
E19A                  _cr
E19A  7F0013                                  clr             TCSR_COL
E19D  B60012                                  lda             TCSR_ROW
E1A0  B1180A                                  cmpa    GFX_FG_HGHT
E1A3  2C0F                                    bge             _scroll
E1A5  7C0012                                  inc             TCSR_ROW
                      
E1A8  2030                                    bra             3f
E1AA                  _backspace
E1AA  B60013                                  lda             TCSR_COL
E1AD  272B                                    beq             3f
E1AF  7A0013                                  dec             TCSR_COL
                                              ;dec    EDT_BFR_CSR
E1B2  2026                                    bra             3f
                      
E1B4                  _scroll                 
E1B4  B61809                                  lda             GFX_FG_WDTH
E1B7  4C                                      inca
E1B8  C602                                    ldb             #2
E1BA  3D                                      mul
E1BB  8E0400                                  ldx             #VIDEO_START
E1BE  308B                                    leax    d,X
E1C0  108E0400                                ldy             #VIDEO_START
E1C4  EC81            1                       ldd             ,x++
E1C6  EDA1                                    std             ,y++
E1C8  8C17FF                                  cmpx    #VIDEO_END
E1CB  2DF7                                    blt             1b
E1CD  8620                                    lda             #' '
E1CF  F60015                                  ldb             TEXT_ATTRIB
E1D2  EDA1            2                       std             ,y++
E1D4  108C17FF                                cmpy    #VIDEO_END
E1D8  2DF8                                    blt             2b
                      
E1DA  3536            3                       puls    D, X, Y
E1DC  39                                      rts
                      
E1DD                  text_out        ; output the string pointed to by X using the current attribute
E1DD  3416                                    pshs    D,X
E1DF  A680            1                       lda             ,X+             
E1E1  2705                                    beq             2f                              
E1E3  BDE173                                  jsr             char_out
E1E6  20F7                                    bra             1b
E1E8  3516            2                       puls    D,X
E1EA  39                                      rts
                      
                      
E1EB                  tcsr_pos        ; load into X according to TCSR_ROW & TCSR_COL
                      
E1EB  3406                                    pshs    D                               ; save for later clean up
E1ED  B60012                                  lda     TCSR_ROW                ; A: cursor row
E1F0  F60013                                  ldb             TCSR_COL                ; B: cursor column
E1F3  BDE1F9                                  jsr     tcsr_pos_reg    ; X: position within the video buffer
E1F6  3506                                    puls    D                               ; clean up the registers
E1F8  39                                      rts                                             ; return
                      
                      
E1F9                  tcsr_pos_reg    ; load into X according to text cursor position (A:ROW, B:COL)
E1F9  3406                                    pshs    D                                               ; save A and B 
E1FB  3406                                            pshs    D                                       ; again, save A and B
E1FD  8E0400                                                  ldx             #VIDEO_START    ; point X to the start of the video buffer
E200  48                                                      lsla                                    ; account for the attribute byte
E201  F61809                                                  ldb             GFX_FG_WDTH             ; load the max horizontal character position
E204  5C                                                      incb                                    ; correct for width
E205  3D                                                      mul                                             ; offset the horizontial position
E206  308B                                                    leax    D,X                             ; within the video buffer
E208  3506                                            puls    D                                       ; restore A and B
E20A  58                                              lslb                                            ; correct vertical to account for height
E20B  3085                                            leax    b,x                                     ; offset into the video buffer
E20D  8C17FF                                          cmpx    #VIDEO_END                      ; was the video buffer exceeded
E210  2303                                            bls             1f                                      ; branch out if not
E212  8E17FE                                          ldx             #VIDEO_END-1            ; point X to the very last cell as an error
E215  3506            1                       puls    D                                               ; final register clean up
E217  39                                      rts                                                             ; return
                      
E218                  starting_screen ; clear and display the starting screen condition
                                      ; load the default graphics mode
E218  8602                                    lda             #$02
E21A  B71800                                  sta             GFX_FLAGS
                                      ; set the text attribute default
E21D  86A2                                    lda             #$a2
E21F  B70015                                  sta             TEXT_ATTRIB     
                                      ; clear screen
E222  BDE159                                  jsr             clear_text_screen
                                      ; display the text prompt
E225  8EE033                                  ldx             #prompt_msg
E228  BDE1DD                                  jsr             text_out
                                      ; start the first anchor
E22B  B60012                                  lda             TCSR_ROW
E22E  B70018                                  sta             TCSR_ANC_ROW
E231  B60013                                  lda             TCSR_COL
E234  B70019                                  sta             TCSR_ANC_COL
E237  7F001A                                  clr             TCSR_ANC_ADR
E23A  7F001B                                  clr             TCSR_ANC_ADR+1
E23D  39                                      rts
                      
E23E                  ok_prompt ; display the ready prompt
                                      ; load the default graphics mode
E23E  8602                                    lda             #$02
E240  B71800                                  sta             GFX_FLAGS
                                      ; set the text attribute default
E243  86A2                                    lda             #$a2
E245  B70015                                  sta             TEXT_ATTRIB     
                                      ; clear screen
E248  BDE159                                  jsr             clear_text_screen
                                      ; display the text prompt
E24B  8EE076                                  ldx             #prompt_ready
E24E  BDE1DD                                  jsr             text_out
                                      ; start the first anchor
E251  B60012                                  lda             TCSR_ROW
E254  B70018                                  sta             TCSR_ANC_ROW
E257  B60013                                  lda             TCSR_COL
E25A  B70019                                  sta             TCSR_ANC_COL
E25D  7F001A                                  clr             TCSR_ANC_ADR
E260  7F001B                                  clr             TCSR_ANC_ADR+1
E263  39                                      rts
                      
                      
E264                  execute_command ; parse and run the string that is currently in the hardware EDT_BUFFER register
E264  B6193C                                  lda             EDT_BUFFER
E267  8120                                    cmpa    #$20
E269  277E                                    beq             1000f
                      
E26B  860A                                    lda             #$0a
E26D  BDE173                                  jsr             char_out
                      
                                      ; parse
E270  BDE2EA                                  jsr             lookup_cmd
                      
                                      ; [L] = test load "test.hex"
E273  8100                                    cmpa    #0
E275  2742                                    beq             999f                            ; do syntax error
E277  8101                                    cmpa    #1                              
E279  2712                                    beq             1f                              ; do "cls"
E27B  8102                                    cmpa    #2                              
E27D  271A                                    beq             2f                              ; do "load"
E27F  8103                                    cmpa    #3
E281  271E                                    beq             3f                              ; do "exec"
E283  8104                                    cmpa    #4
E285  2729                                    beq             4f                              ; do "reset"
E287  8105                                    cmpa    #5
E289  2728                                    beq             5f                              ; do "exit"
E28B  202C                                    bra             999f                            ; syntax error
                      
E28D                  1 ; cls
E28D  86A2                                    lda             #$a2
E28F  B70015                                  sta             TEXT_ATTRIB     
                                      ; clear screen
E292  BDE159                                  jsr             clear_text_screen
E295  BDE23E                                  jsr             ok_prompt
E298  39                                      rts             
                      
E299                  2 ; load
E299  BDE13F                                  jsr     test_load_hex                   
E29C  8602                                    lda             #$02                    ; load the default graphics mode
E29E  8DED                                    bsr             1b
E2A0  39                                      rts
                      
E2A1                  3 ; exec                        
E2A1  B6181F                                  lda             FIO_ERR_FLAGS   ; load the errors flag
E2A4  8180                                    cmpa    #$80                    ; test for bit: file not found?
E2A6  2704                                    beq             31f                             ; dont call the sub if it wasnt loaded
E2A8  AD9F0010                                jsr             [$0010]                 ; call the loaded subroutine
E2AC                  31 ; skip exec
E2AC  BDE23E                                  jsr             ok_prompt               
E2AF  39                                      rts
                      
E2B0                  4 ; reset
E2B0  7EE079                                  jmp             reset
                      
E2B3                  5 ; exit
E2B3  8617                                    lda             #$17                    ; $17 = SYSTEM: Shutdown
E2B5  B71820                                  sta             FIO_COMMAND             ; send the command 
E2B8  39                                      rts
                      
                      
E2B9                  999             ; Report a Syntax Error
E2B9  8EE322                                  ldx             #strz_syntax_error
E2BC  BDE1DD                                  jsr             text_out
E2BF  863A                                    lda             #':'
E2C1  BDE173                                  jsr             char_out
E2C4  8620                                    lda             #' '
E2C6  BDE173                                  jsr             char_out
E2C9  8622                                    lda             #$22                    ; "
E2CB  BDE173                                  jsr             char_out
E2CE  8E193C                                  ldx             #EDT_BUFFER
E2D1  BDE1DD                                  jsr             text_out
E2D4  8622                                    lda             #$22                    ; "
E2D6  BDE173                                  jsr             char_out
E2D9  860A                                    lda             #$0a
E2DB  BDE173                                  jsr             char_out
E2DE  8EE076                                  ldx             #prompt_ready
E2E1  BDE1DD                                  jsr             text_out
E2E4  860A                                    lda             #$0a
E2E6  BDE173                                  jsr             char_out
E2E9                  1000 ; return from subroutine
E2E9  39                                      rts
                      
E2EA                  lookup_cmd      ; return in A index of the command
                                              ; or A = 0 if command not found
E2EA  3434                                    pshs    B, X, Y
E2EC  8601                                    lda             #1                              ; RET = 1
E2EE  3402                                    pshs    A                               ; push local RET onto the stack
E2F0  4F                                      clra                                    ; A = Working Accumilator                       
E2F1  5F                                      clrb                                    ; B = EDT_BUFFER[B] index
E2F2  8E193C                                  ldx             #EDT_BUFFER             ; X = EDT_BUFFER[0]
E2F5  108EE331                                ldy             #command_LUT    ; Y points to the position within the lookup table
E2F9                  1 ; loop:                                       
E2F9  A685                                    lda             B, X                    ; load A from EDT_BUFFER[X]     
E2FB  81FF                                    cmpa    #$ff                    ; compare A with 0xFF
E2FD  271C                                    beq             3f                              ; branch if EQUAL to failure
E2FF  8100                                    cmpa    #$00                    ; compare A with NULL-TERMINATION
E301  271A                                    beq             4f                              ; branch if EQUAL to success
E303  8A20                                    ora             #$20                    ; force lower case
E305  A1A0                                    cmpa    ,Y+                             ; compare A with command_LUT[Y]
E307  2603                                    bne             2f                              ; branch if NOT equal to next_token
E309  5C                                      incb                                    ; increment index in EDT_BUFFER[B]
                                              ;leay   1,Y                             ; increment Y
E30A  20ED                                    bra             1b                              ; branch back to loop           
E30C                  2 ; next_token:
E30C  6CE4                                    inc             0,S                             ; increment RET
E30E  5F                                      clrb                                    ; clear EDT_BUFFER[B] index
                                              ; move Y to the beginning of the next label
E30F                  5 ; lp_1:
E30F  A6A0                                    lda             ,Y+                             ; load a with the current character in the LUT
E311  81FF                                    cmpa    #$ff                    ; if were at the end of the LUT
E313  2706                                    beq             3f                              ; branch to failure
E315  8100                                    cmpa    #$00                    ; end of a token
E317  26F6                                    bne             5b                              ; keep searching if not
                                              ;lda            ,Y+                             ; increment to the start of next token
E319  20DE                                    bra             1b                              ; branch back to loop    
E31B                  3 ; failure:
E31B  6FE4                                    clr             0,S                             ; RET = 0
E31D                  4 ; success:
E31D  3502                                    puls    A                               ; recover local RET
E31F  3534                                    puls    B, X, Y
E321  39                                      rts                                             ; return RET                    
                      
                      
E322                  strz_syntax_error
E322  3F2053796E746178204572726F7200                         fcn             "? Syntax Error"
E331                  command_LUT 
E331  636C7300                                fcn             "cls"                   ; 1
E335  6C6F616400                              fcn             "load"                  ; 2
E33A  6578656300                              fcn             "exec"                  ; 3
E33F  726573657400                            fcn             "reset"                 ; 4
E345  6578697400                              fcn             "exit"                  ; 5
E34A  FF                                      fcb             0xFF
                      
                      
                      
                      
                      ; ***********************************************************
                      
                      
                      ; interrupt vectors
FFF0                                                  org  $fff0
FFF0  E01D            HARD_RSRVD      fdb  do_RSRV    ; Motorola RESERVED Hardware Interrupt Vector
FFF2  E01A            HARD_SWI3       fdb  do_SWI3    ; SWI3 Hardware Interrupt Vector
FFF4  E017            HARD_SWI2       fdb  do_SWI2    ; SWI2 Hardware Interrupt Vector
FFF6  E014            HARD_FIRQ       fdb  do_FIRQ    ; FIRQ Hardware Interrupt Vector
FFF8  E011            HARD_IRQ        fdb  do_IRQ     ; IRQ Hardware Interrupt Vector
FFFA  E00E            HARD_SWI        fdb  do_SWI     ; SWI/SYS Hardware Interrupt Vector
FFFC  E00B            HARD_NMI        fdb  do_NMI     ; NMI Hardware Interrupt Vector
FFFE  E000            HARD_RESET      fdb  ROM_ENTRY  ; RESET Hardware Interrupt Vector
                      
0000                                          END
