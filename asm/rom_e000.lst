                      ; ****************
                      ; * ROM_E000.asm *
                      ; *  KERNEL ROM  *
                      ; ****************
                      
0000                                  INCLUDE "rom_e000_h.asm"
                      ; ******************
                      ; * ROM_E000_H.asm *
                      ; ******************
                      
                      
                      ; system call macro to support the Warte variant 
                      ;               of the MC6809e, the 6809w. This replaces
                      ;               the SWI3 instruction with the SYS #n OS9 
                      ;               style system call instruction.
                      SYS             macro
                                      SWI3
                                      fcb             \1              
                                      endm
                                                              
                      ; reserved system variables
                      
                      ;               org     $0100   ; for now, just place reserved kernal variables at $0100
                      ;                               ; after the rom kernel vectors are clearly established
                      ;                               ; move this origin to just after them.
                      ;
                      ;TCSR_ROW       fcb     0       ; current text cursor row
                      ;TCSR_COL       fcb     0       ; current text cursor column
                      ;TCSR_ATTRIB    fcb     $10     ; current cursor attribute
                      ;TEXT_ATTRIB    fcb     $a2     ; current text attribute
                      ;TCSR_ANC_ROW   fcb     0       ; beginning row of line currently being edited
                      ;TCSR_ANC_COL   fcb     0       ; beginning column of line currently being edited
                      ;TCSR_ANC_ADR   fdb     0       ; anchor address
                      ;TCSR_EDT_ADR   fdb     0       ; address when enter was pressed during line edit
                      ;DEF_GFX_FLAGS  fcb     $02     ; default graphics flags        ($02)
                      ;;TCSR_DECAY    fdb     $0000   ; counter delay for the cursor
                      ;TCSR_DECAY     fcb     $00     ; counter delay for the cursor
                      
0100                  user_vars_page  equ     $0100   ; user variables page = $0100 - $01ff
0000                                  INCLUDE "mem_map.asm"
                      ;  **********************************************
                      ;  * Allocated 64k Memory Mapped System Symbols *
                      ;  **********************************************
                      
                      
                      ;  SOFTWARE Interrupt Vectors:
0000                  SOFT_RESET      equ     $0000   ; Software RESET Vector
0002                  SOFT_NMI        equ     $0002   ; Software NMI Vector
0004                  SOFT_SWI        equ     $0004   ; Software SWI Vector
0006                  SOFT_IRQ        equ     $0006   ; Software IRQ Vector
0008                  SOFT_FIRQ       equ     $0008   ; Software FIRQ Vector
000A                  SOFT_SWI2       equ     $000a   ; Software SWI2 Vector
000C                  SOFT_SWI3       equ     $000c   ; Software SWI3 Vector
000E                  SOFT_RSRVD      equ     $000e   ; Software Motorola Reserved Vector
                      
                      ;  Zero-Page Kernal Variables:
0010                  SYSTEM_VARS     equ     $0010   ; start kernal vectors and variables
0010                  KVEC_EXEC       equ     $0010   ; KERNEL Vector:  Exec
0012                  KVEC_CLS        equ     $0012   ; KERNEL Vector:  Clear Text Screen
0014                  KVEC_CHAROUT    equ     $0014   ; KERNEL Vector:  Character Out
0016                  KVEC_SHUTDOWN   equ     $0016   ; KERNEL Vector:  System Shutdown
                      
                      ;  Stack Frames:
0100                  U_STK_BTM       equ     $0100   ; 256 bytes default user stack space
0200                  U_STK_TOP       equ     $0200   ; User Stack initial address
0200                  S_STK_BTM       equ     $0200   ; 512 bytes default system stack space
0400                  S_STK_TOP       equ     $0400   ; System Stack initial address
                      
                      ;  Video Buffer Memory (target = $0400):
0400                  VIDEO_START     equ     $0400   ; Start of 5KB Video Buffer Memory
17FF                  VIDEO_END       equ     $17ff   ; Last Byte of 5KB Video Buffer Memory
                      
                      ;  Graphics Hardware Registers:
1800                  GFX_BEGIN       equ     $1800   ; start of graphics hardware registers
1800                  GFX_CLK_DIV     equ     $1800   ; (Byte) 60 hz Clock Divider:
                                                      ;      bit 7: 0.46875 hz
                                                      ;      bit 6: 0.9375 hz
                                                      ;      bit 5: 1.875 hz
                                                      ;      bit 4: 3.75 hz
                                                      ;      bit 3: 7.5 hz
                                                      ;      bit 2: 15.0 hz
                                                      ;      bit 1: 30.0 hz
                                                      ;      bit 0: 60.0 hz
1801                  GFX_FLAGS       equ     $1801   ; (Byte) gfx system flags:
                                                      ;      bit 7: VSYNC
                                                      ;      bit 6: backbuffer enable
                                                      ;      bit 5: swap backbuffers (on write)
                                                      ;      bit 4: reserved
                                                      ;      bits 2-3 = 'Background' graphics modes (20KB buffer)
                                                      ;          0) NONE (forced black background)
                                                      ;          1) Tiled 16x16 mode
                                                      ;          2) Overscan Tile 16x16 mode
                                                      ;          3) 128x80 x 256-Colors
                                                      ;      bits 0-1 = 'Foreground' graphics modes (5KB buffer)
                                                      ;          0) 256x160 x 2-Color (with disable flag)
                                                      ;          1) Glyph Mode (32x20 text)
                                                      ;          2) Glyph Mode (64x40 text)
                                                      ;          3) 128x80 x 16-Color
1802                  GFX_AUX equ     $1802   ; (Byte) gfx auxillary/emulation flags:
                                                      ;      bit 7: 1:fullscreen / 0:windowed
                                                      ;      bit 6: reserved
                                                      ;      bit 5: reserved
                                                      ;      bit 4: reserved
                                                      ;      bit 3: reserved
                                                      ;      bit 0-2: monitor display index (0-7)
1803                  GFX_TIMING_W    equ     $1803   ; (Word) horizontal timing
1805                  GFX_TIMING_H    equ     $1805   ; (Word) vertical timing
1807                  GFX_PAL_INDX    equ     $1807   ; (Byte) gfx palette index (0-255)
1808                  GFX_PAL_DATA    equ     $1808   ; (Word) gfx palette color bits RGBA4444
                      
                      ;  Paged Foreground Graphics Mode Hardware Registers:
180A                  GFX_FG_BEGIN    equ     $180a   ; start of paged foreground gfxmode registers
180A                  GFX_FG_WDTH     equ     $180a   ; (Byte) Foreground Unit Width-1
180B                  GFX_FG_HGHT     equ     $180b   ; (Byte) Foreground Unit Height-1
180C                  GFX_FONT_IDX    equ     $180c   ; (Byte) Font Glyph Index
180D                  GFX_FONT_DAT    equ     $180d   ; (8-Bytes) Font Glyph Data Buffer
1814                  GFX_FG_END      equ     $1814   ; end of paged foreground gfxmode registers
                      
                      ;  Paged Background Graphics Mode Hardware Registers:
1815                  GFX_BG_BEGIN    equ     $1815   ; start of paged background gfxmode registers
1815                  GFX_EXT_ADDR    equ     $1815   ; (Word) 20K extended graphics addresses
1817                  GFX_EXT_DATA    equ     $1817   ; (Byte) 20K extended graphics RAM data
1818                  GFX_BG_ARG1     equ     $1818   ; (Byte) first read/write argument for the blit commands
1819                  GFX_BG_CMD      equ     $1819   ; (Byte) Blit Commands on the indexed bitmap buffer
                                                      ;      0x01: Clear Screen     (with color index in GFX_BG_ARG1)
                                                      ;      0x02: unassigned
                                                      ;      0x03: unassigned
                                                      ;      0x04: Scroll Left      (by pixels x GFX_BG_ARG1)
                                                      ;      0x05: Scroll Right     (by pixels x GFX_BG_ARG1)
                                                      ;      0x06: Scroll Up        (by pixels x GFX_BG_ARG1)
                                                      ;      0x07: Scroll Down      (by pixels x GFX_BG_ARG1)
                                                      ;      0x08: Copy Buffer      (From Active to Inactive)
1819                  GFX_BG_END      equ     $1819   ; end of paged background gfxmode registers
                      
                      ;  Mouse Cursor Hardware Registers:
181A                  CSR_BEGIN       equ     $181a   ; start of mouse cursor hardware registers
181A                  CSR_XPOS        equ     $181a   ; (Word) horizontal mouse cursor coordinate
181C                  CSR_YPOS        equ     $181c   ; (Word) vertical mouse cursor coordinate
181E                  CSR_XOFS        equ     $181e   ; (Byte) horizontal mouse cursor offset
181F                  CSR_YOFS        equ     $181f   ; (Byte) vertical mouse cursor offset
1820                  CSR_SIZE        equ     $1820   ; (Byte) cursor size (0-15) 0:off
1821                  CSR_SCROLL      equ     $1821   ; (Signed) MouseWheel Scroll: -1, 0, 1
1822                  CSR_FLAGS       equ     $1822   ; (Byte) mouse button flags:
                                                      ;      bits 0-5: button states
                                                      ;      bits 6-7: number of clicks
1823                  CSR_PAL_INDX    equ     $1823   ; (Byte) mouse cursor color palette index (0-15)
1824                  CSR_PAL_DATA    equ     $1824   ; (Word) mouse cursor color palette data RGBA4444
1826                  CSR_BMP_INDX    equ     $1826   ; (Byte) mouse cursor bitmap pixel offset
1827                  CSR_BMP_DATA    equ     $1827   ; (Byte) mouse cursor bitmap pixel index color
1827                  CSR_END equ     $1827   ; end of mouse cursor hardware registers
                      
                      ;  Debugger Hardware Registers:
1828                  DBG_BEGIN       equ     $1828   ; Start of Debugger Hardware Registers
1828                  DBG_BRK_ADDR    equ     $1828   ; (Word) Address of current breakpoint
182A                  DBG_FLAGS       equ     $182a   ; (Byte) Debug Specific Hardware Flags
                                                      ;      bit 7: Debug Enable
                                                      ;      bit 6: Single Step Enable
                                                      ;      bit 5: clear all breakpoints
                                                      ;      bit 4: Toggle Breakpoint at DEBUG_BRK_ADDRESS
                                                      ;      bit 3: FIRQ  (on low to high edge)
                                                      ;      bit 2: IRQ   (on low to high edge)
                                                      ;      bit 1: NMI   (on low to high edge)
                                                      ;      bit 0: RESET (on low to high edge)
182A                  DBG_END equ     $182a   ; End of the Debugger Hardware Registers
                      
                      ;  Sprite Hardware Registers:
182B                  SPR_BEGIN       equ     $182b   ; Start of Sprite Hardware Registers
                      
                      ;  Sprite Flag Registers:
182B                  SPR_ENABLE      equ     $182b   ; (4-Bytes) sprite Enable Bits. 1 bit per sprite
182F                  SPR_COL_ENA     equ     $182f   ; (4-Bytes) sprite collision enable. 1 bit per sprite
1833                  SPR_COL_TYP     equ     $1833   ; (4-Bytes) sprite collision type (0:hitbox, 1:pixel perfect)
                      
                      ;  Sprite Palette Registers:
1837                  SPR_PAL_INDX    equ     $1837   ; (Byte) color palette index
1838                  SPR_PAL_DATA    equ     $1838   ; (Word) indexed sprite palette entry color bits RGBA4444
                      
                      ;  Sprite Index Register:
183A                  SPR_INDEX       equ     $183a   ; (Byte) 0-31 indexes the 'current' sprite
                      
                      ;  Indexed Sprite Registers:
183B                  SPR_COL_DET     equ     $183b   ; (4-Bytes) Collision detection bits. One bit per colliding sprite.
183F                  SPR_H_POS       equ     $183f   ; (Sint16) signed 16-bit integer
1841                  SPR_V_POS       equ     $1841   ; (Sint16) signed 16-bit integer
1843                  SPR_X_OFS       equ     $1843   ; (Sint8) signed 8-bit integer horizontal display offset
1844                  SPR_Y_OFS       equ     $1844   ; (Sint8) signed 8-bit integer vertical display offset
1845                  SPR_PRIO        equ     $1845   ; (Byte) Sprite Display Priority:
                                                      ;      0) displays directly behind all foreground modes
                                                      ;      1) displays infront of Glyph32 layer 0 but all other foreground modes
                                                      ;      2) displays infront of Glyph32 layer 1 but all other foreground modes
                                                      ;      3) displays infront of Glyph32 layer 2 but all other foreground modes
                                                      ;      4) displays infront of Glyph32 layer 3 but all other foreground modes
                                                      ;      5) displays infront of Debug layer, but behind the mouse cursor
                                                      ;      6) displays infront of Mouse Cursor layer (in index order)
                                                      ;      7) displays in sprite order
                      
                      ;  Sprite Indexed Bitmap Pixel Data:
1846                  SPR_BMP_INDX    equ     $1846   ; (Byte) Sprite pixel offset (Y*16+X)
1847                  SPR_BMP_DATA    equ     $1847   ; (Byte) Sprite color palette index data
                      
                      ;  End of Sprite Hardware Registers
1847                  SPR_END equ     $1847   ; End of the Sprite Hardware Registers
                      
                      ;  End ofthe GFX Hardware Registers
1848                  GFX_END equ     $1848   ; end of the GFX Hardware Registers
                      
                      ;  File I/O Hardware Registers:
1848                  FIO_BEGIN       equ     $1848   ; start of file i/o hardware registers
1848                  FIO_ERR_FLAGS   equ     $1848   ; (Byte) file i/o system flags:
                                                      ;      bit 7:   file not found
                                                      ;      bit 6:  end of file
                                                      ;      bit 5:   buffer overrun
                                                      ;      bit 4: wrong file type
                                                      ;      bit 3: directory not found
                                                      ;      bit 2: too many file handles
                                                      ;      bit 1: incorrect file handle
                                                      ;      bit 0: not yet assigned
1849                  FIO_COMMAND     equ     $1849   ; (Byte) OnWrite - command to execute
                                                      ;      $00 = Reset/Null
                                                      ;      $01 = Open/Create Binary File for Reading
                                                      ;      $02 = Open/Create Binary File for Writing
                                                      ;      $03 = Open/Create Binary File for Append
                                                      ;      $04 = Close File
                                                      ;      $05 = Read Byte
                                                      ;      $06 = Write Byte
                                                      ;      $07 = Load Hex Format File
                                                      ;      $08 = Write Hex Format Line
                                                      ;      $09 = Get File Length (FIO_BFRLEN = file length
                                                      ;      $0A = Load Binary File (read into FIO_BFROFS - FIO_BFROFS+FIO_BFRLEN)
                                                      ;      $0B = Save Binary File (wrote from FIO_BFROFS to FIO_BFROFS+FIO_BFRLEN)
                                                      ;      $0C = (not yet designed) List Directory
                                                      ;      $0D = Make Directory
                                                      ;      $0E = Change Directory
                                                      ;      $0F = Rename Directory
                                                      ;      $10 = Remove Directory
                                                      ;      $11 = Delete File
                                                      ;      $12 = Rename file
                                                      ;      $13 = Copy File
                                                      ;      $14 = Seek Start
                                                      ;      $15 = Seek Current
                                                      ;      $16 = Seek End
                                                      ;      $17 = SYSTEM: Shutdown
                                                      ;      $18 = SYSTEM: Load Compilation Date
184A                  FIO_HANDLE      equ     $184a   ; (Byte) file handle or ZERO
184B                  FIO_BFROFS      equ     $184b   ; (Word) start of I/O buffer
184C                  FIO_BFRLEN      equ     $184c   ; (Word) length of I/O buffer
184E                  FIO_IODATA      equ     $184e   ; (Byte) input / output character
184F                  FIO_RET_COUNT   equ     $184f   ; (Byte) number of return entries
1850                  FIO_RET_INDEX   equ     $1850   ; (Byte) command return index
1851                  FIO_RET_BUFFER  equ     $1851   ; (Char Array 256) paged return buffer
1951                  FIO_FILEPATH    equ     $1951   ; (Char Array 256) file path and argument buffer
1A51                  FIO_END equ     $1a51   ; end of file i/o hardware registers
                      
                      ;  Keyboard Hardware Registers:
1A52                  KEY_BEGIN       equ     $1a52   ; start of keyboard hardware registers
1A52                  CHAR_Q_LEN      equ     $1a52   ; (char) # of characters waiting in queue       (Read Only)
1A53                  CHAR_SCAN       equ     $1a53   ; read next character in queue       (not popped when read)
1A54                  CHAR_POP        equ     $1a54   ; (char) next character waiting in queue (popped when read)
1A55                  XKEY_BUFFER     equ     $1a55   ; (128 bits) 16 bytes for XK_KEY data buffer    (Read Only)
1A65                  EDT_BFR_CSR     equ     $1a65   ; (Byte) cursor position within edit buffer    (Read/Write)
1A66                  EDT_BUFFER      equ     $1a66   ; (256 Bytes) line editing character buffer    (Read/Write)
1B66                  KEY_END equ     $1b66   ; end of keyboard hardware registers
                      
                      ;  Gamepad Hardware Registers:
1B67                  JOYS_BEGIN      equ     $1b67   ; start of gamepad hardware registers
1B67                  JOYS_1_BTN      equ     $1b67   ; (Word) button bits: room for up to 16 buttons  (realtime)
1B69                  JOYS_1_DBND     equ     $1b69   ; (Byte) PAD 1 analog deadband; default is 5   (read/write)
1B6A                  JOYS_1_LTX      equ     $1b6a   ; (char) PAD 1 LThumb-X position (-128 _ +127)   (realtime)
1B6B                  JOYS_1_LTY      equ     $1b6b   ; (char) PAD 1 LThumb-Y position (-128 _ +127)   (realtime)
1B6C                  JOYS_1_RTX      equ     $1b6c   ; (char) PAD 1 RThumb-X position (-128 _ +127)   (realtime)
1B6D                  JOYS_1_RTY      equ     $1b6d   ; (char) PAD 1 RThumb-Y position (-128 _ +127)   (realtime)
1B6E                  JOYS_1_Z1       equ     $1b6e   ; (char) PAD 1 left trigger        (0 - 127)     (realtime)
1B6F                  JOYS_1_Z2       equ     $1b6f   ; (char) PAD 1 right trigger       (0 - 127)     (realtime)
                      
1B70                  JOYS_2_BTN      equ     $1b70   ; (Word) button bits: room for up to 16 buttons  (realtime)
1B72                  JOYS_2_DBND     equ     $1b72   ; (Byte) PAD 2 analog deadband; default is 5   (read/write)
1B73                  JOYS_2_LTX      equ     $1b73   ; (char) PAD 2 LThumb-X position (-128 _ +127)   (realtime)
1B74                  JOYS_2_LTY      equ     $1b74   ; (char) PAD 2 LThumb-Y position (-128 _ +127)   (realtime)
1B75                  JOYS_2_RTX      equ     $1b75   ; (char) PAD 2 RThumb-X position (-128 _ +127)   (realtime)
1B76                  JOYS_2_RTY      equ     $1b76   ; (char) PAD 2 RThumb-Y position (-128 _ +127)   (realtime)
1B77                  JOYS_2_Z1       equ     $1b77   ; (char) PAD 2 left trigger        (0 - 127)     (realtime)
1B78                  JOYS_2_Z2       equ     $1b78   ; (char) PAD 2 right trigger       (0 - 127)     (realtime)
1B79                  JOYS_END        equ     $1b79   ; end of gamepad hardware registers
                      
                      ;  Math Hardware Registers:
1B7A                  MATH_BEGIN      equ     $1b7a   ; start of math hardware registers
1B7A                  MATH_RNDINT     equ     $1b7a   ; (Word) 16-bit random integer
1B7C                  MATH_RNDHALF    equ     $1b7c   ; (Word) normalized half-precision float (0.0 - 1.0)
1B7E                  MATH_END        equ     $1b7e   ; end of math hardware registers
                      
                      ;  Reserved Hardware:
1B7F                  RESERVED_HDW    equ     $1b7f   ; Reserved 1150 bytes ($1B7F - $1FFD)
                      
                      ;  Memory Bank Selects (external 2MB QSPI ISSI 16Mbit SerialRAM):
                      ;  https://www.mouser.com/ProductDetail/ISSI/IS66WVS2M8BLL-104NLI?qs=doiCPypUmgFx786bHGqGiQ%3D%3D
1FFE                  RAMBANK_SEL_1   equ     $1ffe   ; (Byte)Indexes 256 x 8kb banks
1FFF                  RAMBANK_SEL_2   equ     $1fff   ; (Byte)Indexes 256 x 8kb banks
                      
                      ;  Standard Usable (from FAST static 32KB) RAM:
2000                  RAM_START       equ     $2000   ; Begin System RAM (32k)
9FFF                  RAM_END equ     $9fff   ; End System RAM
                      
                      ;  Switchable RAM Banks (from SLOW external serial 16MB RAM chip):
A000                  RAM_BANK_1      equ     $a000   ; switched 8KB ram bank 1
C000                  RAM_BANK_2      equ     $c000   ; switched 8KB ram bank 2
                      
                      ;  Bios Kernal ROM:
E000                  BIOS_ROM        equ     $e000   ; Begin BIOS Kernal ROM (8KB)
                      
                      ;  Hardware Interrupt Vectors:
FFF0                  HARD_RSRVD      equ     $fff0   ; Motorola RESERVED Hardware Interrupt Vector
FFF2                  HARD_SWI3       equ     $fff2   ; SWI3 Hardware Interrupt Vector
FFF4                  HARD_SWI2       equ     $fff4   ; SWI2 Hardware Interrupt Vector
FFF6                  HARD_FIRQ       equ     $fff6   ; FIRQ Hardware Interrupt Vector
FFF8                  HARD_IRQ        equ     $fff8   ; IRQ Hardware Interrupt Vector
FFFA                  HARD_SWI        equ     $fffa   ; SWI / SYS Hardware Interrupt Vector
FFFC                  HARD_NMI        equ     $fffc   ; NMI Hardware Interrupt Vector
FFFE                  HARD_RESET      equ     $fffe   ; RESET Hardware Interrupt Vector
                      
                      ; **********************
                      ; * KERNEL ROM VERSION *
                      ; **********************
                      VERSION macro
                                      fcc             "V0.03"
                                      endm 
                      
0000                                  org     $0000
                                      
0000  E026                            fdb     do_RESET        ; Software RESET Vector
0002  E011                            fdb     do_NMI          ; Software NMI Vector
0004  E014                            fdb     do_SWI          ; Software SWI Vector
0006  E017                            fdb     do_IRQ          ; Software IRQ Vector
0008  E01A                            fdb     do_FIRQ         ; Software FIRQ Vector
000A  E01D                            fdb     do_SWI2         ; Software SWI2 Vector
000C  E020                            fdb     do_SWI3         ; Software SWI3 Vector
000E  E023                            fdb     do_RSRV         ; Software Motorola Reserved Vector     
                      
                      ; KERNEL Soft Vectors
0012                                  org     $0012
                                      ; fdb   $0000           ; [KVEC_EXEC]           Exec software vector
0012  E114                            fdb     clear_text_screen       ; [KVEC_CLS]    Clear Text Screen software vector
0014  E12E                            fdb     char_out        ; [KVEC_CHAROUT]        Text Character Out software vector                      
0016  E1D4            1               fdb     shutdown        ; [KVEC_SHUTDOWN]       System Shutdown software vector         
                      
0018  00              TCSR_ROW        fcb     0       ; current text cursor row
0019  00              TCSR_COL        fcb     0       ; current text cursor column
001A  10              TCSR_ATTRIB     fcb     $10     ; current cursor attribute
001B  A2              TEXT_ATTRIB     fcb     $a2     ; current text attribute
001C  00              TCSR_ANC_ROW    fcb     0       ; beginning row of line currently being edited
001D  00              TCSR_ANC_COL    fcb     0       ; beginning column of line currently being edited
001E  0000            TCSR_ANC_ADR    fdb     0       ; anchor address
0020  0000            TCSR_EDT_ADR    fdb     0       ; address when enter was pressed during line edit
0022  02              DEF_GFX_FLAGS   fcb     $02     ; default graphics flags        ($02)
                      ;TCSR_DECAY     fdb     $0000   ; counter delay for the cursor
0023  00              TCSR_DECAY      fcb     $00     ; counter delay for the cursor
                      
                      
                      ; ***************************************
                      ; * Read Only Sytem KERNAL ROM          *
                      ; ***************************************
                                         
E000                                  org     $E000  
                                  ;* Power On Initialization            
E000                  ROM_ENTRY   
E000  CE0200                          ldu     #U_STK_TOP              ; top of user stack     
E003  10CE0400                        lds     #S_STK_TOP              ; top of stack space   
E007  8EE02A                          ldx     #reset
E00A  BF0010                          stx     KVEC_EXEC        
E00D  6E9F0000                        jmp     [SOFT_RESET]      
                      
                                  
                                                 
E011  7EE029          do_NMI          jmp     just_rti        ;* NMI Vector Handler
E014  7EE029          do_SWI          jmp     just_rti        ;* SWI Vector Handler (do_SWI)   
E017  7EE029          do_IRQ          jmp     just_rti        ;* IRQ Vector Handler  
E01A  7EE029          do_FIRQ         jmp     just_rti        ;* FIRQ Vector Handler             
E01D  7EE029          do_SWI2         jmp     just_rti        ;* SWI2 Vector Handler                     
E020  7EE029          do_SWI3         jmp     just_rti        ;* SWI3 Vector Handler         
E023  7EE02A          do_RSRV         jmp     reset           ;* Reserved Vector Handler            
E026  7EE02A          do_RESET        jmp     reset           ;* Reset Vector Handler         
                                  
                      ;********************
                      ;* RESET
                      ;**************************                                             
                                              
                      ; NOTES:  
                      ;
                      ;       SYNC still needs to be implemented along with NMI, IRQ, and FIRQ handlers
                      
E029                  just_rti        
E029  3B                              rti 
                      
E02A                  reset   ; display the starting screen
E02A  BDE1DA                          jsr     starting_screen
E02D  860A                            lda     #$0a
E02F  AD9F0014                        jsr     [KVEC_CHAROUT]
                              ; fresh anchor
E033  B60018                          lda     TCSR_ROW
E036  B7001C                          sta     TCSR_ANC_ROW
E039  B60019                          lda     TCSR_COL
E03C  B7001D                          sta     TCSR_ANC_COL
E03F  7F001E                          clr     TCSR_ANC_ADR
E042  7F001F                          clr     TCSR_ANC_ADR+1                  
E045  7F0023                          clr     TCSR_DECAY
                      
                      ;               ldb     #$10
                      ;               stb     TCSR_ATTRIB
                      ;               ldd     #0
                      ;               std     TCSR_DECAY
                      
                      ; **** main KERNEL loop **********************************************
E048                  main_kernel
                              ; rotate the cursor attributes
E048  B61800                          lda     GFX_CLK_DIV     ; load the clock divisions
E04B  8408                            anda    #%00001000      ; mask out the 0.5 hz bit
E04D  B10023                          cmpa    TCSR_DECAY      ; compare with the previous clock state
E050  2723                            beq     1f              ; skip when no change                   
E052  B70023                          sta     TCSR_DECAY      ; store the new clock state
E055  F6001A                          ldb     TCSR_ATTRIB     ; B: current cursor attribute
E058  B6001A                          lda     TCSR_ATTRIB     ; A: current cursor attribute
E05B  84F0                            anda    #$F0            ; mask out the background bits
E05D  B7001A                          sta     TCSR_ATTRIB     ; store masked attribute                        
E060  5C                              incb                    ; increment the background color
E061  C40F                            andb    #$0F            ; mask out the foreground color bits
E063  FA001A                          orb     TCSR_ATTRIB     ; update with the background color bits
E066  F7001A                          stb     TCSR_ATTRIB     ; store the new cursor attribute
                              ; mark the anchor
E069  B6001C                          lda     TCSR_ANC_ROW    ; A: text cursor row
E06C  F6001D                          ldb     TCSR_ANC_COL    ; B: text cursor column
E06F  BDE1B5                          jsr     tcsr_pos_reg    ; X: calculated offset within the video buffer
E072  BF001E                          stx     TCSR_ANC_ADR
                      
                      ; color the anchor character
                      ;               ldb     #$3B            ; anchor color attribute
                      ;               stb     1,X             ; highlight the anchor character
                      
E075                  1       ; display the cursor
E075  BDE1A7                          jsr     tcsr_pos        ; fetch x from row/col
E078  8620                            lda     #' '            ; space character
E07A  F6001A                          ldb     TCSR_ATTRIB     ; load the current attribute
E07D  ED84                            std     0,x             ; place the cursor onto the screen
                                      
                              ; check for a key in the queue
E07F  B61A52                          lda     CHAR_Q_LEN      ; load the length of the key queue
E082  27C4                            beq     main_kernel     ; loop if nothing is queued
                      
                              ; delete the old cursor
E084  BDE1A7                          jsr     tcsr_pos        ; calculate X from row/col
E087  8620                            lda     #' '            ; load a blank space character
E089  F6001B                          ldb     TEXT_ATTRIB     ; load the current text attribute
E08C  ED84                            std     0,x             ; store the colored character at X (row/col)
                                      
                              ; display typed character
E08E  B61A54                          lda     CHAR_POP        ; pop the last typed character  
                              ; was [ENTER] pressed
E091  810D                            cmpa    #$0D            ; check for [ENTER]
E093  262F                            bne     2f              ; nope, that wasn't it. Skip ahead to 2
E095  3402                            pshs    A               ; save the typed key
E097  B60018                          lda     TCSR_ROW        ; A: current cursor row
E09A  F60019                          ldb     TCSR_COL        ; B: current cursor column
E09D  BDE1B5                          jsr     tcsr_pos_reg    ; X: calculated offset 
E0A0  BF0020                          stx     TCSR_EDT_ADR    ; save as the end of the current edit buffer
                      ;       ; color highlight the pending string 
                      ;               ldb     #$4c            
                      ;               ldx     TCSR_ANC_ADR                    
                      ;               leax    1,x
                      ;99             stb     ,x++
                      ;               cmpx    TCSR_EDT_ADR
                      ;               blt     99b
                      ;       ; copy the string to the hardware buffer
E0A3  108E1A66                        ldy     #EDT_BUFFER     ; Y: current hardware edit buffer
E0A7  BE001E                          ldx     TCSR_ANC_ADR    ; X: anchor or start of the edit string
E0AA  A681            4               lda     ,x++            ; load the character from the screen
E0AC  A7A0                            sta     ,y+             ; store it into the hardware edit buffer
E0AE  BC0020                          cmpx    TCSR_EDT_ADR    ; check for the end of the string
E0B1  2DF7                            blt     4b              ; keep looping if not at the end
E0B3  6FA4                            clr     ,y              ; append a NULL character in the hardware buffer
E0B5  BDE292                          jsr     execute_command ; parse and run the command                     
E0B8  3502                            puls    A               ; A: restored Key typed
                                      
E0BA  BE0018                          ldx     TCSR_ROW
E0BD  BC001C                          cmpx    TCSR_ANC_ROW
E0C0  2702                            beq     2f
E0C2  2004                            bra     3f
E0C4  AD9F0014        2               jsr     [KVEC_CHAROUT]  ; display the last typed character
E0C8  810D            3               cmpa    #$0D            ; Was [ENTER] pressed?
E0CA  261A                            bne     2f              ; no, move on
                              ; [ENTER] pressed                       
E0CC  B6001C                          lda     TCSR_ANC_ROW
E0CF  F6001D                          ldb     TCSR_ANC_COL
E0D2  BDE1B5                          jsr     tcsr_pos_reg
E0D5  F6001B                          ldb     TEXT_ATTRIB
E0D8  E701                            stb     1,x
                              ; move the anchor to the new cursor position
E0DA  B60018                          lda     TCSR_ROW
E0DD  B7001C                          sta     TCSR_ANC_ROW
E0E0  B60019                          lda     TCSR_COL
E0E3  B7001D                          sta     TCSR_ANC_COL
E0E6                  2       ; display the new cursor
E0E6  BDE1A7                          jsr     tcsr_pos        ; fetch x from row/col
E0E9  8620                            lda     #' '            ; space character
E0EB  F6001A                          ldb     TCSR_ATTRIB     ; load the current attribute
E0EE  ED84                            std     0,x             ; place the cursor onto the screen              
                              ; end of main kernel loop
E0F0  7EE048                          jmp     main_kernel     ; continue the main kernel loop
                      
                      
                      ; **** SUBROUTINES ***************************************************
                      
                      
                      ; FILE SYSTEM TESTS:
                      
E0F3                  load_hex
E0F3  8607                            lda     #$07            ; command: LoadHex
E0F5  B71849                          sta     FIO_COMMAND     ; executre the command
E0F8  B61848                          lda     FIO_ERR_FLAGS   ; load the errors flag
E0FB  8180                            cmpa    #$80            ; test for bit: file not found?
E0FD  2706                            beq     1f              ; dont call the sub if it wasnt loaded
E0FF  8110                            cmpa    #$10            ; test for bit: file not found?
E101  270A                            beq     2f              ; dont call the sub if it wasnt loaded
E103  200E                            bra     9f
                      
E105                  1       ; display, "ERROR: File Not Found!"
E105  8EE497                          ldx     #strz_nofile_error
E108  BDE198                          jsr     text_out
E10B  2006                            bra     9f
E10D                  2       ; display, "ERROR: Wrong File Type"
E10D  8EE4CE                          ldx     #strz_wrongfile_error
E110  BDE198                          jsr     text_out
E113                  9       ; return from subroutine
E113  39                              rts
                      
                      
                      ; **** SYSTEM CALLS ******************************
                      
E114                  clear_text_screen       ; clear the text screen
E114  3416                            pshs    D,X
E116  8E0400                          ldx     #VIDEO_START
E119  8620                            lda     #' '
E11B  F6001B                          ldb     TEXT_ATTRIB
E11E  ED81            1               std     ,x++
E120  8C17FF                          cmpx    #VIDEO_END
E123  23F9                            bls     1b      
E125  3516                            puls    D,X             
E127  7F0018                          clr     TCSR_ROW
E12A  7F0019                          clr     TCSR_COL                        
E12D  39                              rts
                      
                      
E12E                  char_out        
                              ; Display character in the A register to the screen
                              ; at the current cursor position and in the 
                              ; current color.
E12E  3436                            pshs    D, X, Y
                              ; just return if A=null
E130  4D                              tsta
E131  2762                            beq     3f
E133  F6001B                          ldb     TEXT_ATTRIB
E136  8D6F                            bsr     tcsr_pos        ; find X from Row and Col
E138  810A                            cmpa    #$0a
E13A  2719                            beq     _cr
E13C  810D                            cmpa    #$0D
E13E  2715                            beq     _cr
E140  8108                            cmpa    #$08            ; backspace
E142  2721                            beq     _backspace
E144  8120                            cmpa    #$20
E146  2D4D                            blt     3f
                              ; standard printable character
E148  ED84                            std     ,x
E14A  7C0019                          inc     TCSR_COL
E14D  B60019                          lda     TCSR_COL
E150  B1180A                          cmpa    GFX_FG_WDTH
E153  2340                            bls     3f
E155                  _cr
E155  7F0019                          clr     TCSR_COL
E158  B60018                          lda     TCSR_ROW
E15B  B1180B                          cmpa    GFX_FG_HGHT
E15E  2C0F                            bge     _scroll
E160  7C0018                          inc     TCSR_ROW
E163  2030                            bra     3f
E165                  _backspace
E165  B60019                          lda     TCSR_COL
E168  272B                            beq     3f
E16A  7A0019                          dec     TCSR_COL
E16D  2026                            bra     3f
E16F                  _scroll                 
E16F  B6180A                          lda     GFX_FG_WDTH
E172  4C                              inca
E173  C602                            ldb     #2
E175  3D                              mul
E176  8E0400                          ldx     #VIDEO_START
E179  308B                            leax    d,X
E17B  108E0400                        ldy     #VIDEO_START
E17F  EC81            1               ldd     ,x++
E181  EDA1                            std     ,y++
E183  8C17FF                          cmpx    #VIDEO_END
E186  2DF7                            blt     1b
E188  8620                            lda     #' '
E18A  F6001B                          ldb     TEXT_ATTRIB
E18D  EDA1            2               std     ,y++
E18F  108C17FF                        cmpy    #VIDEO_END
E193  2DF8                            blt     2b
                      
E195  3536            3                       puls    D, X, Y
E197  39                                      rts
                      
E198                  text_out        
                              ; output the string pointed to by X using the current attribute
E198  3416                            pshs    D,X
E19A  A680            1               lda     ,X+             
E19C  2706                            beq     2f                              
E19E  AD9F0014                        jsr     [KVEC_CHAROUT]
E1A2  20F6                            bra     1b
E1A4  3516            2               puls    D,X
E1A6  39                              rts
                      
E1A7                  tcsr_pos        
                              ; load into X according to TCSR_ROW & TCSR_COL
E1A7  3406                            pshs    D               ; save for later clean up
E1A9  B60018                          lda     TCSR_ROW        ; A: cursor row
E1AC  F60019                          ldb     TCSR_COL        ; B: cursor column
E1AF  BDE1B5                          jsr     tcsr_pos_reg    ; X: position within the video buffer
E1B2  3506                            puls    D               ; clean up the registers
E1B4  39                              rts                     ; return
                      
                      
E1B5                  tcsr_pos_reg    
                              ; load into X according to text cursor position (A:ROW, B:COL)
E1B5  3406                            pshs    D               ; save A and B 
E1B7  3406                                    pshs    D               ; again, save A and B
E1B9  8E0400                                          ldx     #VIDEO_START    ; point X to the start of the video buffer
E1BC  48                                              lsla                    ; account for the attribute byte
E1BD  F6180A                                          ldb     GFX_FG_WDTH     ; load the max horizontal character position
E1C0  5C                                              incb                    ; correct for width
E1C1  3D                                              mul                     ; offset the horizontial position
E1C2  308B                                            leax    D,X             ; within the video buffer
E1C4  3506                                    puls    D               ; restore A and B
E1C6  58                                      lslb                    ; correct vertical to account for height
E1C7  3085                                    leax    b,x             ; offset into the video buffer
E1C9  8C17FF                                  cmpx    #VIDEO_END      ; was the video buffer exceeded
E1CC  2303                                    bls     1f              ; branch out if not
E1CE  8E17FE                                  ldx     #VIDEO_END-1    ; point X to the very last cell as an error
E1D1  3506            1               puls    D               ; final register clean up
E1D3  39                              rts                     ; return
                                              
E1D4                  shutdown        
                              ; shutdown the system
E1D4  8617                            lda     #$17            ; $17 = SYSTEM: Shutdown
E1D6  B71849                          sta     FIO_COMMAND     ; send the command 
E1D9  39                              rts
                      
E1DA                  starting_screen 
                              ; clear and display the starting screen condition
                              ; load the default graphics mode
E1DA  B60022                          lda     DEF_GFX_FLAGS
E1DD  B71801                          sta     GFX_FLAGS
                              ; set the text attribute default
E1E0  86A2                            lda     #$a2
E1E2  B7001B                          sta     TEXT_ATTRIB     
                              ; clear screen
E1E5  AD9F0012                        jsr     [KVEC_CLS]      ; clear_text_screen             
                              ; display the text prompt
E1E9  8EE547                          ldx     #prompt_msg1
E1EC  BDE198                          jsr     text_out
E1EF  8EE56C                          ldx     #prompt_msg2
E1F2  BDE198                          jsr     text_out                
                              ; display the compilation date
E1F5  8618                            lda     #$18
E1F7  B71849                          sta     FIO_COMMAND
E1FA  8E1951                          ldx     #FIO_FILEPATH
E1FD  BDE198                          jsr     text_out        
                              ; display more of the text prompt
E200  8EE576                          ldx     #prompt_msg3
E203  BDE198                          jsr     text_out                
                              ; start the first anchor
E206  B60018                          lda     TCSR_ROW
E209  B7001C                          sta     TCSR_ANC_ROW
E20C  B60019                          lda     TCSR_COL
E20F  B7001D                          sta     TCSR_ANC_COL
E212  7F001E                          clr     TCSR_ANC_ADR
E215  7F001F                          clr     TCSR_ANC_ADR+1
E218  39                              rts
                      
E219                  ok_prompt 
                              ; display the ready prompt
E219  8EE598                          ldx     #prompt_ready
E21C  BDE198                          jsr     text_out
E21F  860A                            lda     #$0A
E221  AD9F0014                        jsr     [KVEC_CHAROUT]
E225  39                              rts
                      
E226                  text_screen_reset
                              ; load the default graphics mode
E226  B60022                          lda     DEF_GFX_FLAGS
E229  B71801                          sta     GFX_FLAGS
                              ; set the text attribute default
                                      ;lda    #$a2
                                      ;sta    TEXT_ATTRIB     
                              ; clear screen
E22C  AD9F0012                        jsr     [KVEC_CLS]      ;clear_text_screen
                              ; start the first anchor
E230  B60018                          lda     TCSR_ROW
E233  B7001C                          sta     TCSR_ANC_ROW
E236  B60019                          lda     TCSR_COL
E239  B7001D                          sta     TCSR_ANC_COL
E23C  7F001E                          clr     TCSR_ANC_ADR
E23F  7F001F                          clr     TCSR_ANC_ADR+1
E242  39                              rts
                      
E243                  get_argument_attrib     
                              ; set text attribute from cmd argument
E243  7D1951                          tst     FIO_FILEPATH
E246  10270047                        lbeq    13f
E24A  B61951                          lda     FIO_FILEPATH
E24D  8A20                            ora     #$20            ; force lower case
E24F  8161                            cmpa    #'a'
E251  2D0A                            blt     101f
E253  8166                            cmpa    #'f'
E255  2E06                            bgt     101f
E257  8061                            suba    #'a'
E259  8B0A                            adda    #10
E25B  200A                            bra     102f
E25D  8130            101             cmpa    #'0'
E25F  2D30                            blt     13f             ; invalid, just use defaults
E261  8139                            cmpa    #'9'
E263  2E2C                            bgt     13f             ; also invalid
E265  8030                            suba    #'0'
E267  F61952          102             ldb     FIO_FILEPATH+1
E26A  CA20                            orb     #$20            ; force lower case
E26C  C161                            cmpb    #'a'
E26E  2D0A                            blt     103f
E270  C166                            cmpb    #'f'
E272  2E06                            bgt     103f
E274  C061                            subb    #'a'
E276  CB0A                            addb    #10
E278  200A                            bra     104f
E27A  C130            103             cmpb    #'0'
E27C  2D13                            blt     13f             ; invalid, just use defaults
E27E  C139                            cmpb    #'9'
E280  2E0F                            bgt     13f             ; also invalid
E282  C030                            subb    #'0'
E284  48              104             lsla
E285  48                              lsla
E286  48                              lsla
E287  48                              lsla
E288  B7001B                          sta     TEXT_ATTRIB
E28B  FA001B                          orb     TEXT_ATTRIB
E28E  F7001B                          stb     TEXT_ATTRIB
E291  39              13              rts
                      
E292                  execute_command
                              ; parse and run the string that is currently in the hardware EDT_BUFFER register
E292  B61A66                          lda     EDT_BUFFER
E295  8120                            cmpa    #$20
E297  1027018E                        lbeq    1000f
E29B  860A                            lda     #$0a
E29D  AD9F0014                        jsr     [KVEC_CHAROUT]
                              ; parse
E2A1  BDE450                          jsr             lookup_cmd
                              ; switch to command
E2A4  8100                            cmpa    #0
E2A6  10270145                        lbeq    999f            ; do syntax error
E2AA  8101                            cmpa    #1              
E2AC  10270039                        lbeq    1f              ; do "cls"
E2B0  8102                            cmpa    #2                              
E2B2  1027003E                        lbeq    2f              ; do "load"
E2B6  8103                            cmpa    #3
E2B8  10270041                        lbeq    3f              ; do "exec"
E2BC  8104                            cmpa    #4
E2BE  10270066                        lbeq    4f              ; do "reset"
E2C2  8105                            cmpa    #5
E2C4  10270066                        lbeq    5f              ; do "exit"
E2C8  8106                            cmpa    #6
E2CA  10270065                        lbeq    6f              ; screen
E2CE  8107                            cmpa    #7
E2D0  102700A8                        lbeq    7f              ; dir
E2D4  8108                            cmpa    #8
E2D6  102700C1                        lbeq    8f              ; chdir
E2DA  8109                            cmpa    #9
E2DC  102700D3                        lbeq    9f              ; attr
E2E0  810A                            cmpa    #10
E2E2  102700DE                        lbeq    debug_10        ; debug
E2E6  160106                          lbra    999f            ; syntax error
E2E9                  1 ; cls
E2E9  BDE243                          jsr     get_argument_attrib
E2EC  AD9F0012                        jsr     [KVEC_CLS]      ;clear_text_screen
E2F0  BDE219                          jsr     ok_prompt
E2F3  39                              rts     
E2F4                  2 ; load <arg>
E2F4  BDE0F3                          jsr     load_hex                        
E2F7  8602                            lda     #$02            ; load the default graphics mode
E2F9  BDE219                          jsr     ok_prompt
E2FC  39                              rts
E2FD                  3 ; exec                        
E2FD  B61848                          lda     FIO_ERR_FLAGS   ; load the errors flag
E300  8480                            anda    #$80            ; test for bit: file not found?         
E302  4D                              tsta    
E303  261F                            bne     31f             ; dont call the sub if it wasnt loaded
E305  BE0010                          ldx     KVEC_EXEC       ; whats in the exec vector?
E308  8CE02A                          cmpx    #reset          ; if its set to default
E30B  2717                            beq     31f             ; then skip to OK prompt                
E30D  B6182A                          lda     DBG_FLAGS       ; read debug flags
E310  843F                            anda    #~$C0           ; mask out debug and single step enable bits
E312  B7182A                          sta     DBG_FLAGS       ; store debug flags             
E315  AD9F0010                        jsr     [KVEC_EXEC]     ; call the loaded subroutine
E319  B61801                          lda     GFX_FLAGS       ; check video mode
E31C  B10022                          cmpa    DEF_GFX_FLAGS   ; compare against defaults
E31F  2703                            beq     32f             ; skip the CLS if the mode hasnt changed
E321  BDE226                          jsr     text_screen_reset
E324                  32 ; skip cls
                                      ;jsr    ok_prompt               
                                      ;rts
E324                  31 ; skip exec
                                      ;jsr    [KVEC_CLS]      ;clear_text_screen
E324  BDE219                          jsr     ok_prompt
E327  39                              rts
                      
E328                  4 ; reset
E328  8600                            lda     #$00            ; $00 = Reset/Null
E32A  B71849                          sta     FIO_COMMAND     ; send the command
E32D  39                              rts
                      
E32E                  5 ; exit
E32E  AD9F0016                        jsr     [KVEC_SHUTDOWN] ; call kernel shutdown via software vector
E332  39                              rts
                      
E333                  6 ; screen <arg>
                              ; $30 = 0       32x20
                              ; $31 = 1       64x40
                              ; $32 = 2       128x80 bitmap mode
                              ; check the argument
E333  B61951                          lda     FIO_FILEPATH
E336  8130                            cmpa    #'0'            ; mode 0 = 32x20 
E338  2712                            beq     60f
E33A  8131                            cmpa    #'1'            ; mode 0 = 32x20 
E33C  271E                            beq     61f
E33E  8132                            cmpa    #'2'            ; mode 0 = 32x20 
E340  272A                            beq     62f
                              ; ERROR: Argument out of Range!
E342  8EE4AF                          ldx     #strz_range_error
E345  BDE198                          jsr     text_out
E348  BDE219                          jsr     ok_prompt       
E34B  39                              rts
E34C                  60 ; 32x20 text
E34C  B61801                          lda     GFX_FLAGS
E34F  84FC                            anda    #$FC            ; mask out FG mode
E351  8A01                            ora     #$01            ; mask in 32 column text mode
E353  B71801                          sta     GFX_FLAGS       ; update the display mode
E356  B70022                          sta     DEF_GFX_FLAGS   ; replace the defaults
E359  7EE328                          jmp     4b              ; system: reset
E35C                  61 ; 64x40 text (default)
E35C  B61801                          lda     GFX_FLAGS
E35F  84FC                            anda    #$FC            ; mask out FG mode
E361  8A02                            ora     #$02            ; mask in 64 column text mode
E363  B71801                          sta     GFX_FLAGS       ; update the display mode
E366  B70022                          sta     DEF_GFX_FLAGS   ; replace the defaults
E369  7EE328                          jmp     4b              ; system: reset
                      
E36C                  62 ; 128x80 16-color bitmap
E36C  B61801                          lda     GFX_FLAGS
E36F  84FC                            anda    #$FC            ; mask out FG mode
E371  8A03                            ora     #$03            ; mask in 64 column text mode
E373  B71801                          sta     GFX_FLAGS       ; update the display mode
E376  B70022                          sta     DEF_GFX_FLAGS   ; replace the defaults
E379  7EE328                          jmp     4b              ; system: reset
                      
E37C                  7 ; dir
E37C  860C                            lda     #$0c            ; list files
E37E  B71849                          sta     FIO_COMMAND
E381  4F                              clra
E382  8E1851                          ldx     #FIO_RET_BUFFER
E385  B71850          71              sta     FIO_RET_INDEX   ; get the File[A]
E388  BDE198                          jsr     text_out        ; send it to the screen
E38B  4C                              inca    
E38C  B1184F                          cmpa    FIO_RET_COUNT   ; how many entries?
E38F  26F4                            bne     71b             
E391  860A                            lda     #$0A
E393  AD9F0014                        jsr     [KVEC_CHAROUT]
E397  BDE219                          jsr     ok_prompt       
E39A  39                              rts
                      
E39B                  8 ; chdir
E39B  860E                            lda     #$0e            ; $0E = command "CHDIR"
E39D  B71849                          sta     FIO_COMMAND
E3A0  B61848                          lda     FIO_ERR_FLAGS
E3A3  8408                            anda    #$08            ; directory not found
E3A5  8108                            cmpa    #$08
E3A7  2606                            bne     81f             ; nope, just end
E3A9  8EE4E7                          ldx     #strz_dirnope_error
E3AC  BDE198                          jsr     text_out
E3AF  BDE219          81              jsr     ok_prompt       
E3B2  39                              rts
                      
E3B3                  9 ; color       
E3B3  BDE243                          jsr     get_argument_attrib
E3B6  8E0401                          ldx     #VIDEO_START+1
E3B9  E781            91              stb     ,x++
E3BB  8C17FF                          cmpx    #VIDEO_END
E3BE  23F9                            bls     91b
                                      ;lda    #$0A
                                      ;jsr    [KVEC_CHAROUT]
E3C0  BDE219                          jsr     ok_prompt       
E3C3  39                              rts             
                                      
E3C4                  debug_10 ; debug                        
E3C4  B61848                          lda     FIO_ERR_FLAGS   ; load the errors flag
E3C7  8480                            anda    #$80            ; test for bit: file not found?         
E3C9  4D                              tsta    
E3CA  261F                            bne     101f            ; dont call the sub if it wasnt loaded
E3CC  BE0010                          ldx     KVEC_EXEC       ; whats in the exec vector?
E3CF  8CE02A                          cmpx    #reset          ; if its set to default
E3D2  2717                            beq     101f            ; then skip to OK prompt                
E3D4  B6182A                          lda     DBG_FLAGS       ; read debug flags
E3D7  8AC0                            ora     #$C0            ; set debug and single step enable bits
E3D9  B7182A                          sta     DBG_FLAGS       ; store debug flags             
E3DC  AD9F0010                        jsr     [KVEC_EXEC]     ; call the loaded subroutine            
E3E0  B61801                          lda     GFX_FLAGS       ; check video mode
E3E3  B10022                          cmpa    DEF_GFX_FLAGS   ; compare against defaults
E3E6  2703                            beq     101f            ; skip the CLS if the mode hasnt changed
E3E8  BDE226                          jsr     text_screen_reset
E3EB                  101 ; skip exec
E3EB  BDE219                          jsr     ok_prompt
E3EE  39                              rts
                      
E3EF                  999     ; Report a Syntax Error
E3EF  8EE487                          ldx     #strz_syntax_error
E3F2  BDE198                          jsr     text_out
E3F5  BDE219                          jsr     ok_prompt       
E3F8  39                              rts
E3F9  863A                            lda     #':'
E3FB  AD9F0014                        jsr     [KVEC_CHAROUT]
E3FF  8620                            lda     #' '
E401  AD9F0014                        jsr     [KVEC_CHAROUT]
E405  8622                            lda     #$22            ; "
E407  AD9F0014                        jsr     [KVEC_CHAROUT]
E40B  8E1A66                          ldx     #EDT_BUFFER
E40E  BDE198                          jsr     text_out
E411  8622                            lda     #$22            ; "
E413  AD9F0014                        jsr     [KVEC_CHAROUT]
E417  860A                            lda     #$0a
E419  AD9F0014                        jsr     [KVEC_CHAROUT]
E41D  8EE598                          ldx     #prompt_ready
E420  BDE198                          jsr     text_out
E423  860A                            lda     #$0a
E425  AD9F0014                        jsr     [KVEC_CHAROUT]
E429                  1000    ; return from subroutine
E429  39                              rts
                      
E42A                  fetch_cl_argument       
                              ; copy everything past the first space character to FIO_FILEPATH
E42A  3432                            pshs    A, X, Y
E42C  8E1A66                          ldx     #EDT_BUFFER
E42F  108E1951                        ldy     #FIO_FILEPATH
E433                  1 ; look for space
E433  A680                            lda     ,X+
E435  8120                            cmpa    #' '
E437  2705                            beq     2f              ; copy the argument
E439  8C1B65                          cmpx    #EDT_BUFFER+255
E43C  26F5                            bne     1b
E43E                  2 ; loop through the argument
E43E  6F1F                            clr     -1,X
E440  A680                            lda     ,X+
E442  A7A0                            sta     ,Y+
E444  4D                              tsta
E445  2706                            beq     3f      
E447  108C1A50                        cmpy    #FIO_FILEPATH+255
E44B  26F1                            bne     2b
E44D  3532            3               puls    A, X, Y
E44F  39                              rts
                      
                      
E450                  lookup_cmd      
                              ; return in A index of the command
                              ; or A = 0 if command not found
E450  BDE42A                          jsr     fetch_cl_argument
E453  3434                            pshs    B, X, Y
E455  8601                            lda     #1              ; RET = 1
E457  3402                            pshs    A               ; push local RET onto the stack
E459  4F                              clra                    ; A = Working Accumilator                       
E45A  5F                              clrb                    ; B = EDT_BUFFER[B] index
E45B  8E1A66                          ldx     #EDT_BUFFER     ; X = EDT_BUFFER[0]
E45E  108EE504                        ldy     #command_LUT    ; Y points to the position within the lookup table
E462                  1 ; loop:       
E462  A685                            lda     B, X            ; load A from EDT_BUFFER[X]                             
E464  8100                            cmpa    #$00            ; compare A with NULL-TERMINATION
E466  271A                            beq     4f              ; branch if EQUAL to success
E468  8A20                            ora     #$20            ; force lower case
E46A  A1A0                            cmpa    ,Y+             ; compare A with command_LUT[Y]
E46C  2603                            bne     2f              ; branch if NOT equal to next_token
E46E  5C                              incb                    ; increment index in EDT_BUFFER[B]
E46F  20F1                            bra     1b              ; branch back to loop           
                                      
E471                  2 ; next_token:
E471  6CE4                            inc     0,S             ; increment RET
E473  5F                              clrb                    ; clear EDT_BUFFER[B] index
                              ; move Y to the beginning of the next label
E474                  5 ; lp_1:
E474  A6A0                            lda     ,Y+             ; load a with the current character in the LUT
E476  81FF                            cmpa    #$ff            ; if were at the end of the LUT
E478  2706                            beq     3f              ; branch to failure
E47A  8100                            cmpa    #$00            ; end of a token
E47C  26F6                            bne     5b              ; keep searching if not
E47E  20E2                            bra     1b              ; branch back to loop    
E480                  3 ; failure:
E480  6FE4                            clr     0,S             ; RET = 0
E482                  4 ; success:
E482  3502                            puls    A               ; recover local RET
E484  3534                            puls    B, X, Y
E486  39                              rts                     ; return RET                    
                      
E487  4552524F523A2053796E746178210A00 strz_syntax_error       fcn     "ERROR: Syntax!\n"
E497  4552524F523A2046696C65204E6F7420466F756E64210A00 strz_nofile_error       fcn     "ERROR: File Not Found!\n"
E4AF  4552524F523A20417267756D656E74206F7574206F662052616E6765210A00 strz_range_error        fcn     "ERROR: Argument out of Range!\n"
E4CE  4552524F523A2057726F6E672046696C652054797065210A00 strz_wrongfile_error    fcn     "ERROR: Wrong File Type!\n"
E4E7  4552524F523A204469726563746F7279204E6F7420466F756E64210A00 strz_dirnope_error      fcn     "ERROR: Directory Not Found!\n"
                      
                      ; console commands
E504                  command_LUT 
E504  636C7300                        fcn     "cls"
E508  6C6F616400                      fcn     "load"
E50D  6578656300                      fcn     "exec"
E512  726573657400                    fcn     "reset"
E518  6578697400                      fcn     "exit"
E51D  73637265656E00                  fcn     "screen"
E524  64697200                        fcn     "dir"
E528  636400                          fcn     "cd"
E52B  636F6C6F7200                    fcn     "color"
E531  646562756700                    fcn     "debug"
E537  FF                              fcb     0xFF
                      
E538  2E2F61736D2F746573742E68657800 test_file       fcn     "./asm/test.hex"
                      
E547  54776F2D504920526574726F20363830390A prompt_msg1     fcc     "Two-PI Retro 6809\n"
E559  42494F53204B45524E454C20                 fcc             "BIOS KERNEL " 
E565                                  VERSION ; version number
E565  56302E3033                      fcc             "V0.03"
E56A  0A00                            fcn     "\n"
E56C  436F6D70696C65642000 prompt_msg2     fcn     "Compiled "                     
E576  0A436F707972696768742843292032303233206279204A6179204661726965730A0A prompt_msg3     fcc     "\nCopyright(C) 2023 by Jay Faries\n\n"
E598  4F4B00          prompt_ready    fcn     "OK"
                      
                      
                      ; ***********************************************************
                      
                      
                      ; interrupt vectors
FFF0                                  org  $fff0
FFF0  E023                            fdb  do_RSRV    ; Motorola RESERVED Hardware Interrupt Vector
FFF2  E020                            fdb  do_SWI3    ; SWI3 Hardware Interrupt Vector
FFF4  E01D                            fdb  do_SWI2    ; SWI2 Hardware Interrupt Vector
FFF6  E01A                            fdb  do_FIRQ    ; FIRQ Hardware Interrupt Vector
FFF8  E017                            fdb  do_IRQ     ; IRQ Hardware Interrupt Vector
FFFA  E014                            fdb  do_SWI     ; SWI/SYS Hardware Interrupt Vector
FFFC  E011                            fdb  do_NMI     ; NMI Hardware Interrupt Vector
FFFE  E000                            fdb  ROM_ENTRY  ; RESET Hardware Interrupt Vector
                      
0000                                  END
